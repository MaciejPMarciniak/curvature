import matplotlib.pyplot as plt
import numpy as np
from numpy.typing import NDArray
from scipy.spatial.distance import cdist

import contour_adjustment


class MyocardialContour:
    """Class to generate the contours of the myocardium.

    The contours are generated based on a gray mask image, generated by a segmentation algorithm,
    containing the LV blood pool, LV myocardium and left atrium. Both endo- and epicardial contours
    are generated.

    Attributes:
        gray_mask:
            The image to generate the contours from.
        endocardial_contour:
            Contour of the edge between the myocardial and blood pool masks.
        epicardial_contour:
            Contour of the remaining edge of the myocardium.
        mask_values:
            The values of the segmentation mask - blood pool, myocardium and atrium.
        mask_intensity_range:
            The number of intensity values that a pixel in the mask can have. Typically, the
            segmentation pixels will be encoded with int8 values, therefore the default value
            of 256 is provided.
    """

    def __init__(self, gray_mask: NDArray) -> None:
        self.gray_mask = gray_mask
        self.endocardial_contour: NDArray
        self.epicardial_contour: NDArray
        self.mask_values = {"LV_bp": 85, "LV_myo": 170, "LA": 255}
        self.mask_intensity_range: int = 256

    def generate_myocardial_contours(self, plot_contours: bool = False) -> None:
        """Generates the endocardial and epicardial contours.

        Args:
            plot_contours: Whether to plot the resulting contours on top of the mask, e.g. for
            verification. Defaults to False.
        """
        self._reindex_atrium()

        endo_edge = self._generate_contour(component="LV_bp")
        self.endocardial_contour = self._interpolate_contour(endo_edge)

        epi_edge = self._generate_contour(component="LV_myo")
        self.epicardial_contour = self._interpolate_contour(epi_edge, interpolation_resolution=2500)

        if plot_contours:
            self.plot_mask_with_contour(self.endocardial_contour, self.epicardial_contour)

    def _reindex_atrium(self) -> None:
        """Adjusts the intensity of the atrium, to not confuse the edge detection."""
        self.gray_mask[self.gray_mask == self.mask_values["LA"]] = 254

    def _generate_contour(self, component: str = "LV_bp") -> NDArray:
        """Creates a contour based on the edges in the mask.

        Args:
            component: Defines which edge to look for. Defaults to "LV_bp".

        Returns:
            The generated contour, with sorted points.
        """
        edge_points = self._find_edge_coordinates(self.mask_values[component])
        ordered_contour = self._order_contour_points(edge_points)
        return ordered_contour

    def _interpolate_contour(
        self, contour: NDArray, interpolation_resolution: int = 500
    ) -> NDArray:
        """Interpolates a contour to a given resolution.

        Args:
            contour:
                The contour to be interpolated. The points must be sorted.
            interpolation_resolution:
                The number of points in the resulting contour. Defaults to 500.

        Returns:
            The interpolated contour.
        """
        interpolation = contour_adjustment.ContourAdjustment(contour, interpolation_resolution)
        interpolation.interpolate()
        return interpolation.adj_contour

    def _find_edge_coordinates(self, edge_value: int) -> NDArray:
        """Finds the coordinates of the image edges with a given value.

        Args:
            edge_value: The difference of interest between the image components.

        Returns:
            Coordinates of the edge.
        """
        assert edge_value < self.mask_intensity_range, (
            f"The contour value cannot be higher than the maximal image intensity ({edge_value=} "
            "provided)"
        )

        row_edges = self._find_pixel2pixel_differences(edge_value=edge_value, axis=1)
        col_edges = self._find_pixel2pixel_differences(edge_value=edge_value, axis=0)

        # Index correction
        corrected_horizontal_coordinates = np.column_stack([row_edges[1] + 0.5, row_edges[0]])
        corrected_vertical_coordinates = np.column_stack([col_edges[1], col_edges[0] + 0.5])

        # Merge vertical and horizontal edge points
        n_edge = np.row_stack([corrected_horizontal_coordinates, corrected_vertical_coordinates])

        return n_edge

    def _order_contour_points(self, coordinates_of_edge: NDArray) -> list[list[float]]:
        """
        Since the ventricle is usually not convex, using radial coordinates can
        be misleading. A simple search deals with the proper order of the points
        and ensures a single-pixel edge.

        Args:
            coordinates_of_edge: list of (x, y) coordinates of the edge on 2D plane

        Returns:
            Sorted list of coordinates of the edge
        """
        sorted_edge = []
        boundary_points = []

        edge_points_distances = self._get_edge_points_distances(coordinates_of_edge)

        # Find the point with lowest vertical value
        cur_point = list(min(coordinates_of_edge, key=lambda t: t[1]))  # type: ignore
        sorted_edge.append(cur_point)

        # Append points to the sorted edge until the boundary conditions are met
        while 1:
            try:
                new_point, is_boundary = self._find_closest_point(
                    coordinates_of_edge, cur_point, sorted_edge, edge_points_distances
                )
            except TypeError:
                # Visualize the points in case of issues
                plt.scatter([p[0] for p in sorted_edge], [p[1] for p in sorted_edge], s=1)
                plt.xlim((0, 256))
                plt.ylim((-256, 0))
                plt.show()
                break

            if is_boundary:
                # Boundary point found
                boundary_points.append(cur_point)

                # If it's the second boundary point, finish
                if len(boundary_points) == 2:
                    break

                # If it's the first boundary point, reverse the order and start searching from the
                # initial point (but in another direction)
                sorted_edge.reverse()
                cur_point = sorted_edge[-1]

            else:
                # Not a boundary point. Append to sorted edge
                cur_point = new_point
                sorted_edge.append(cur_point)

        # For consistency, the contour points are always ordered from the left boundary point
        left_boundary_point = min(boundary_points, key=lambda x: x[0])
        if np.all(left_boundary_point != sorted_edge[0]):
            sorted_edge.reverse()

        return np.array(sorted_edge)

    def _find_pixel2pixel_differences(self, edge_value: int, axis: int) -> NDArray:
        """Finds the borders of the relevant components.

        The differences between consecutive pixels expose the edges between the relevant
        segmentation components.

        Args:
            axis: Defines whether the edge search is vertical (axis=0) or horizontal(axis=1).

        Returns:
            Coordinates of the edge points.
        """
        edge_mask = np.diff(self.gray_mask, axis=axis)

        # Find relevant edge points
        component_edges = np.where(
            np.logical_or(
                edge_mask == edge_value,
                edge_mask == self.mask_intensity_range - edge_value,
            )
        )
        return component_edges

    def _get_edge_points_distances(self, coordinates_of_edge: NDArray) -> NDArray:
        """Calculates the distances between all points in the contour.

        The calculated distance zero is equivalent to multiple points with the exact same
        coordinates. To keep the order of the original points, they must be preserved. However,
        the resulting contour should not have repeated coordinates. Therefore, the zero distance
        is increased to a big value.

        Args:
            coordinates_of_edge: Points found on the edge between the segmentation components.

        Returns:
            The distance matrix between edge points.
        """
        distance_matrix = cdist(coordinates_of_edge, coordinates_of_edge, metric="euclidean")
        distance_matrix[distance_matrix == 0] = 100
        return distance_matrix

    def _find_closest_point(
        self,
        coordinates_of_edge: NDArray,
        cur_point: list[float],
        existing_contour: list,
        distance_matrix: NDArray,
    ) -> tuple[list[float], bool]:
        """Finds the index of the point in the contour that is closest to the given point.

        If no point can be found, it means that the close points must be already within the contour
        and the current point is a boundary point (at the base of the ventricle).

        Args:
            coordinates_of_edge: All points within the edge of the segmentation components.
            cur_point: Coordinates of the reference point.
            existing_contour: Points already added to the contour.
            distance_matrix: The distance matrix between edge points.

        Returns:
            If the current point is NOT a boundary point, returns the index of the closest point
            and a False. Otherwise, returns the current point and True.
        """
        # Find closest point ids
        current_point_id = coordinates_of_edge.tolist().index(cur_point)

        # The distances between adjacent pixel edge points are 1 in either vertical or horizontal
        # direction
        closest_point_id = np.where(distance_matrix[current_point_id, :] <= 1.0)[0]

        # Retrieve points that are not already in the contour
        closest_points = [
            cpi
            for cpi in coordinates_of_edge[closest_point_id].tolist()
            if cpi not in existing_contour
        ]

        # If only one point was found, return it
        if len(closest_points) == 1:
            return closest_points[0], False

        # If more than one point was found, choose the one with lowest vertical value
        if len(closest_points) > 1:
            closest_points.sort(key=lambda x: x[0])
            return closest_points[0], False

        # If no point is found, flag the boundary of the contour
        return cur_point, True

    def plot_mask_with_contour(
        self, contour1: list | None = None, contour2: list | None = None
    ) -> None:
        """Plots the the segmentation mask with provided contours.

        Args:
            contour1: Contour to draw in red. Defaults to None.
            contour2: Contour to draw in blue. Defaults to None.
        """
        plt.imshow(self.gray_mask, cmap="gray")
        if contour1 is not None:
            xc = np.array([x[0] for x in contour1])
            yc = np.array([y[1] for y in contour1])
            plt.plot(xc, yc, "r.-")

        if contour2 is not None:
            xc = np.array([x[0] for x in contour2])
            yc = np.array([y[1] for y in contour2])
            plt.plot(xc, yc, "b.-")
        plt.show()
        plt.clf()
